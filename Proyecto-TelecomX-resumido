ğŸ“Š Telecom X - AnÃ¡lisis de EvasiÃ³n de Clientes (Churn Analysis)
ğŸ¯ IntroducciÃ³n
Objetivo del AnÃ¡lisis: Comprender los factores que llevan a la pÃ©rdida de clientes en Telecom X y proporcionar insights valiosos para reducir la tasa de evasiÃ³n.

Problema: Telecom X enfrenta una alta tasa de cancelaciones y necesita identificar patrones y tendencias en el comportamiento de los clientes para desarrollar estrategias efectivas de retenciÃ³n.

MetodologÃ­a: Aplicaremos tÃ©cnicas de ETL (ExtracciÃ³n, TransformaciÃ³n y Carga), anÃ¡lisis exploratorio de datos (EDA) y visualizaciones estratÃ©gicas para extraer informaciÃ³n valiosa del dataset.

ğŸ“š ImportaciÃ³n de Bibliotecas
# Importar bibliotecas necesarias
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
import json
from collections import Counter

# ConfiguraciÃ³n de visualizaciÃ³n
plt.style.use('default')
sns.set_palette("husl")
warnings.filterwarnings('ignore')

# ConfiguraciÃ³n para mostrar todas las columnas
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
pd.set_option('display.max_colwidth', None)

print("âœ… Bibliotecas importadas exitosamente")
âœ… Bibliotecas importadas exitosamente
ğŸ“‚ ExtracciÃ³n de Datos desde la API
# Cargar los datos desde el archivo JSON local
# Nota: Los datos ya estÃ¡n disponibles localmente desde el repositorio de GitHub
with open('TelecomX_Data.json', 'r', encoding='utf-8') as file:
    data = json.load(file)

print(f"âœ… Datos cargados exitosamente")
print(f"ğŸ“Š Total de registros: {len(data)}")
print(f"ğŸ“‹ Primeros 2 registros:")
for i in range(2):
    print(f"Cliente {i+1}: {data[i]['customerID']}")

# Verificar estructura de un registro para entender el problema
print(f"\nğŸ” Estructura de datos del primer registro:")
print(f"Charges del primer registro: {data[0]['account']['Charges']}")

# Verificar algunos TotalCharges para encontrar valores problemÃ¡ticos
print(f"\nğŸ” Valores de TotalCharges en los primeros 10 registros:")
for i in range(10):
    total_charges = data[i]['account']['Charges']['Total']
    print(f"Cliente {i+1}: '{total_charges}' (tipo: {type(total_charges)})")
âœ… Datos cargados exitosamente
ğŸ“Š Total de registros: 7267
ğŸ“‹ Primeros 2 registros:
Cliente 1: 0002-ORFBO
Cliente 2: 0003-MKNFE

ğŸ” Estructura de datos del primer registro:
Charges del primer registro: {'Monthly': 65.6, 'Total': '593.3'}

ğŸ” Valores de TotalCharges en los primeros 10 registros:
Cliente 1: '593.3' (tipo: <class 'str'>)
Cliente 2: '542.4' (tipo: <class 'str'>)
Cliente 3: '280.85' (tipo: <class 'str'>)
Cliente 4: '1237.85' (tipo: <class 'str'>)
Cliente 5: '267.4' (tipo: <class 'str'>)
Cliente 6: '571.45' (tipo: <class 'str'>)
Cliente 7: '7904.25' (tipo: <class 'str'>)
Cliente 8: '5377.8' (tipo: <class 'str'>)
Cliente 9: '340.35' (tipo: <class 'str'>)
Cliente 10: '5957.9' (tipo: <class 'str'>)
ğŸ”„ TransformaciÃ³n de Datos a DataFrame
# FunciÃ³n auxiliar para convertir valores numÃ©ricos de forma segura
def safe_float_conversion(value, default=0.0):
    """
    Convierte un valor a float de forma segura, manejando casos especiales.
    
    Args:
        value: El valor a convertir
        default: Valor por defecto si la conversiÃ³n falla
    
    Returns:
        float: El valor convertido o el valor por defecto
    """
    try:
        # Si es string, limpiar espacios en blanco
        if isinstance(value, str):
            value = value.strip()
            # Si es string vacÃ­o, devolver default
            if value == '' or value == ' ':
                return default
        
        # Intentar conversiÃ³n
        return float(value)
    except (ValueError, TypeError):
        # Si falla la conversiÃ³n, devolver default
        return default

# FunciÃ³n para aplanar la estructura JSON anidada (CORREGIDA)
def flatten_customer_data(customer_record):
    flat_record = {}
    
    # InformaciÃ³n bÃ¡sica
    flat_record['customerID'] = customer_record['customerID']
    flat_record['Churn'] = customer_record['Churn']
    
    # InformaciÃ³n del cliente
    customer_info = customer_record['customer']
    flat_record['gender'] = customer_info['gender']
    flat_record['SeniorCitizen'] = customer_info['SeniorCitizen']
    flat_record['Partner'] = customer_info['Partner']
    flat_record['Dependents'] = customer_info['Dependents']
    flat_record['tenure'] = customer_info['tenure']
    
    # Servicios telefÃ³nicos
    phone_info = customer_record['phone']
    flat_record['PhoneService'] = phone_info['PhoneService']
    flat_record['MultipleLines'] = phone_info['MultipleLines']
    
    # Servicios de internet
    internet_info = customer_record['internet']
    flat_record['InternetService'] = internet_info['InternetService']
    flat_record['OnlineSecurity'] = internet_info['OnlineSecurity']
    flat_record['OnlineBackup'] = internet_info['OnlineBackup']
    flat_record['DeviceProtection'] = internet_info['DeviceProtection']
    flat_record['TechSupport'] = internet_info['TechSupport']
    flat_record['StreamingTV'] = internet_info['StreamingTV']
    flat_record['StreamingMovies'] = internet_info['StreamingMovies']
    
    # InformaciÃ³n de cuenta (CORREGIDA para manejar valores faltantes)
    account_info = customer_record['account']
    flat_record['Contract'] = account_info['Contract']
    flat_record['PaperlessBilling'] = account_info['PaperlessBilling']
    flat_record['PaymentMethod'] = account_info['PaymentMethod']
    
    # Usar conversiÃ³n segura para valores numÃ©ricos
    flat_record['MonthlyCharges'] = safe_float_conversion(account_info['Charges']['Monthly'])
    flat_record['TotalCharges'] = safe_float_conversion(account_info['Charges']['Total'])
    
    return flat_record

# Convertir todos los registros a formato plano
print("ğŸ”„ Iniciando transformaciÃ³n de datos...")
flattened_data = []
errors_count = 0

for i, record in enumerate(data):
    try:
        flattened_data.append(flatten_customer_data(record))
    except Exception as e:
        errors_count += 1
        print(f"âŒ Error procesando registro {i}: {e}")
        continue

# Crear DataFrame
df = pd.DataFrame(flattened_data)

print("âœ… Datos convertidos a DataFrame exitosamente")
print(f"ğŸ“Š Dimensiones del DataFrame: {df.shape}")
print(f"ğŸ“‹ Columnas: {list(df.columns)}")
print(f"ğŸš¨ Errores durante conversiÃ³n: {errors_count}")

# Verificar valores problemÃ¡ticos en TotalCharges
print(f"\nğŸ” VerificaciÃ³n de TotalCharges:")
print(f"Valores Ãºnicos de TotalCharges (primeros 10): {sorted(df['TotalCharges'].unique())[:10]}")
print(f"Cantidad de TotalCharges = 0: {(df['TotalCharges'] == 0).sum()}")
print(f"Valores nulos en TotalCharges: {df['TotalCharges'].isnull().sum()}")

# Mostrar estadÃ­sticas bÃ¡sicas de las columnas numÃ©ricas
print(f"\nğŸ“Š EstadÃ­sticas bÃ¡sicas de columnas numÃ©ricas:")
numeric_cols = ['SeniorCitizen', 'tenure', 'MonthlyCharges', 'TotalCharges']
print(df[numeric_cols].describe())
ğŸ”„ Iniciando transformaciÃ³n de datos...
âœ… Datos convertidos a DataFrame exitosamente
ğŸ“Š Dimensiones del DataFrame: (7267, 21)
ğŸ“‹ Columnas: ['customerID', 'Churn', 'gender', 'SeniorCitizen', 'Partner', 'Dependents', 'tenure', 'PhoneService', 'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies', 'Contract', 'PaperlessBilling', 'PaymentMethod', 'MonthlyCharges', 'TotalCharges']
ğŸš¨ Errores durante conversiÃ³n: 0

ğŸ” VerificaciÃ³n de TotalCharges:
Valores Ãºnicos de TotalCharges (primeros 10): [np.float64(0.0), np.float64(18.8), np.float64(18.85), np.float64(18.9), np.float64(19.0), np.float64(19.05), np.float64(19.1), np.float64(19.15), np.float64(19.2), np.float64(19.25)]
Cantidad de TotalCharges = 0: 11
Valores nulos en TotalCharges: 0

ğŸ“Š EstadÃ­sticas bÃ¡sicas de columnas numÃ©ricas:
       SeniorCitizen       tenure  MonthlyCharges  TotalCharges
count    7267.000000  7267.000000     7267.000000   7267.000000
mean        0.162653    32.346498       64.720098   2277.182035
std         0.369074    24.571773       30.129572   2268.648587
min         0.000000     0.000000       18.250000      0.000000
25%         0.000000     9.000000       35.425000    396.200000
50%         0.000000    29.000000       70.300000   1389.200000
75%         0.000000    55.000000       89.875000   3778.525000
max         1.000000    72.000000      118.750000   8684.800000
ğŸ§¹ Limpieza y VerificaciÃ³n de Calidad de Datos
# Verificar valores ausentes
print("ğŸ” VALORES AUSENTES POR COLUMNA:")
print("=" * 50)
missing_values = df.isnull().sum()
missing_percentage = (missing_values / len(df)) * 100
missing_df = pd.DataFrame({
    'Valores Ausentes': missing_values,
    'Porcentaje': missing_percentage
})
missing_df = missing_df[missing_df['Valores Ausentes'] > 0].sort_values('Valores Ausentes', ascending=False)
if len(missing_df) > 0:
    display(missing_df)
else:
    print("No hay valores ausentes en el dataset")

# Verificar valores Ãºnicos en Churn (incluyendo cadenas vacÃ­as)
print("\nğŸ¯ VALORES ÃšNICOS EN CHURN:")
print("=" * 50)
churn_counts = df['Churn'].value_counts(dropna=False)
print(churn_counts)

# Verificar si hay cadenas vacÃ­as en Churn
empty_churn = (df['Churn'] == '').sum()
print(f"\nCadenas vacÃ­as en Churn: {empty_churn}")

# Verificar duplicados
print("\nğŸ”„ DUPLICADOS:")
print("=" * 50)
duplicates = df.duplicated().sum()
print(f"Registros duplicados: {duplicates}")

# Verificar duplicados por customerID
duplicate_customers = df['customerID'].duplicated().sum()
print(f"CustomerIDs duplicados: {duplicate_customers}")

# Limpiar datos - eliminar registros con Churn vacÃ­o
df_clean = df.copy()
print(f"\nğŸ§¹ LIMPIEZA DE CHURN:")
print(f"Registros antes de limpieza: {len(df_clean)}")

# Reemplazar cadenas vacÃ­as con NaN y eliminar
df_clean['Churn'] = df_clean['Churn'].replace('', np.nan)
df_clean = df_clean.dropna(subset=['Churn'])

print(f"Registros despuÃ©s de limpieza: {len(df_clean)}")
print(f"Registros eliminados: {len(df) - len(df_clean)}")

# Manejo especÃ­fico de TotalCharges con valores 0
print(f"\nğŸ’° ANÃLISIS DE TOTALCHARGES:")
print(f"Registros con TotalCharges = 0: {(df_clean['TotalCharges'] == 0).sum()}")

# Para clientes con TotalCharges = 0, usar MonthlyCharges * tenure como estimaciÃ³n
zero_total_mask = (df_clean['TotalCharges'] == 0) & (df_clean['tenure'] > 0)
zero_total_count = zero_total_mask.sum()

if zero_total_count > 0:
    print(f"Corrigiendo {zero_total_count} registros con TotalCharges = 0...")
    df_clean.loc[zero_total_mask, 'TotalCharges'] = (
        df_clean.loc[zero_total_mask, 'MonthlyCharges'] * 
        df_clean.loc[zero_total_mask, 'tenure']
    )
    print("âœ… CorrecciÃ³n completada")

print(f"\nğŸ“Š DATASET FINAL LIMPIO:")
print(f"Dimensiones: {df_clean.shape}")
print(f"DistribuciÃ³n de Churn final:")
print(df_clean['Churn'].value_counts())
ğŸ” VALORES AUSENTES POR COLUMNA:
==================================================
No hay valores ausentes en el dataset

ğŸ¯ VALORES ÃšNICOS EN CHURN:
==================================================
Churn
No     5174
Yes    1869
        224
Name: count, dtype: int64

Cadenas vacÃ­as en Churn: 224

ğŸ”„ DUPLICADOS:
==================================================
Registros duplicados: 0
CustomerIDs duplicados: 0

ğŸ§¹ LIMPIEZA DE CHURN:
Registros antes de limpieza: 7267
Registros despuÃ©s de limpieza: 7043
Registros eliminados: 224

ğŸ’° ANÃLISIS DE TOTALCHARGES:
Registros con TotalCharges = 0: 11

ğŸ“Š DATASET FINAL LIMPIO:
Dimensiones: (7043, 21)
DistribuciÃ³n de Churn final:
Churn
No     5174
Yes    1869
Name: count, dtype: int64
ğŸ“Š AnÃ¡lisis de DistribuciÃ³n de Churn (EvasiÃ³n)
# AnÃ¡lisis de la variable objetivo (Churn)
print("ğŸ¯ ANÃLISIS DE DISTRIBUCIÃ“N DE CHURN:")
print("=" * 50)

# Contar y calcular porcentajes
churn_counts = df_clean['Churn'].value_counts()
churn_percentages = df_clean['Churn'].value_counts(normalize=True) * 100

print("DistribuciÃ³n absoluta:")
print(churn_counts)
print("\nDistribuciÃ³n porcentual:")
for category, percentage in churn_percentages.items():
    print(f"{category}: {percentage:.2f}%")

# Crear visualizaciÃ³n
fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# GrÃ¡fico de barras
churn_counts.plot(kind='bar', ax=axes[0], color=['lightblue', 'lightcoral'])
axes[0].set_title('DistribuciÃ³n de Churn - Cantidades', fontsize=14, fontweight='bold')
axes[0].set_xlabel('Churn Status')
axes[0].set_ylabel('NÃºmero de Clientes')
axes[0].tick_params(axis='x', rotation=45)

# Agregar valores en las barras
for i, v in enumerate(churn_counts.values):
    axes[0].text(i, v + 50, str(v), ha='center', va='bottom', fontweight='bold')

# GrÃ¡fico de torta
colors = ['lightblue', 'lightcoral']
wedges, texts, autotexts = axes[1].pie(churn_counts.values, 
                                      labels=churn_counts.index, 
                                      autopct='%1.1f%%',
                                      colors=colors,
                                      startangle=90)
axes[1].set_title('DistribuciÃ³n de Churn - Porcentajes', fontsize=14, fontweight='bold')

# Mejorar la apariencia del grÃ¡fico de torta
for autotext in autotexts:
    autotext.set_color('white')
    autotext.set_fontweight('bold')
    autotext.set_fontsize(12)

plt.tight_layout()
plt.show()

# Calcular tasa de churn
churn_rate = (df_clean['Churn'] == 'Yes').mean() * 100
print(f"\nğŸš¨ TASA DE CHURN: {churn_rate:.2f}%")
print(f"ğŸ“Š De cada 100 clientes, {churn_rate:.0f} abandonan el servicio")
ğŸ¯ ANÃLISIS DE DISTRIBUCIÃ“N DE CHURN:
==================================================
DistribuciÃ³n absoluta:
Churn
No     5174
Yes    1869
Name: count, dtype: int64

DistribuciÃ³n porcentual:
No: 73.46%
Yes: 26.54%

ğŸš¨ TASA DE CHURN: 26.54%
ğŸ“Š De cada 100 clientes, 27 abandonan el servicio
# AnÃ¡lisis de factores clave que influyen en churn
print("ğŸ” ANÃLISIS DE FACTORES CLAVE DE CHURN:")
print("=" * 50)

# FunciÃ³n para analizar tasa de churn por categorÃ­a
def analyze_churn_by_category(df, column):
    """Analiza la tasa de churn por categorÃ­a de una variable"""
    analysis = df.groupby(column).agg({
        'Churn': lambda x: (x == 'Yes').sum(),
        'customerID': 'count'
    })
    analysis.columns = ['Churn_Count', 'Total_Count']
    analysis['Churn_Rate'] = (analysis['Churn_Count'] / analysis['Total_Count'] * 100).round(2)
    analysis = analysis.sort_values('Churn_Rate', ascending=False)
    return analysis

# 1. AnÃ¡lisis por tipo de contrato
print("\nğŸ“‹ CHURN POR TIPO DE CONTRATO:")
print("-" * 40)
contract_analysis = analyze_churn_by_category(df_clean, 'Contract')
display(contract_analysis)

# 2. AnÃ¡lisis por mÃ©todo de pago  
print("\nğŸ’³ CHURN POR MÃ‰TODO DE PAGO:")
print("-" * 40)
payment_analysis = analyze_churn_by_category(df_clean, 'PaymentMethod')
display(payment_analysis)

# 3. AnÃ¡lisis por servicio de internet
print("\nğŸŒ CHURN POR SERVICIO DE INTERNET:")
print("-" * 40)
internet_analysis = analyze_churn_by_category(df_clean, 'InternetService')
display(internet_analysis)

# 4. AnÃ¡lisis por tenure (segmentado)
print("\nğŸ“… CHURN POR SEGMENTOS DE TENURE:")
print("-" * 40)
# Crear segmentos de tenure
df_clean['tenure_segment'] = pd.cut(df_clean['tenure'], 
                                   bins=[0, 12, 24, 48, 100], 
                                   labels=['0-12 meses', '13-24 meses', '25-48 meses', '49+ meses'],
                                   include_lowest=True)

tenure_analysis = analyze_churn_by_category(df_clean, 'tenure_segment')
display(tenure_analysis)

# 5. AnÃ¡lisis por variables demogrÃ¡ficas importantes
print("\nğŸ‘¥ CHURN POR CARACTERÃSTICAS DEMOGRÃFICAS:")
print("-" * 40)

demographic_vars = ['gender', 'SeniorCitizen', 'Partner', 'Dependents']
for var in demographic_vars:
    print(f"\n{var}:")
    demo_analysis = analyze_churn_by_category(df_clean, var)
    display(demo_analysis)

# 6. AnÃ¡lisis de variables numÃ©ricas
print("\nğŸ“ˆ ANÃLISIS DE VARIABLES NUMÃ‰RICAS:")
print("-" * 40)
numeric_vars = ['tenure', 'MonthlyCharges', 'TotalCharges']

for var in numeric_vars:
    churn_yes = df_clean[df_clean['Churn'] == 'Yes'][var]
    churn_no = df_clean[df_clean['Churn'] == 'No'][var]
    
    print(f"\n{var}:")
    print(f"  Promedio (Churn=Yes): {churn_yes.mean():.2f}")
    print(f"  Promedio (Churn=No): {churn_no.mean():.2f}")
    print(f"  Diferencia: {churn_yes.mean() - churn_no.mean():.2f}")
    
    if var == 'tenure':
        print(f"  Los clientes que se van tienen {abs(churn_yes.mean() - churn_no.mean()):.1f} meses {'menos' if churn_yes.mean() < churn_no.mean() else 'mÃ¡s'} de antigÃ¼edad")
    elif 'Charges' in var:
        print(f"  Los clientes que se van pagan ${abs(churn_yes.mean() - churn_no.mean()):.2f} {'menos' if churn_yes.mean() < churn_no.mean() else 'mÃ¡s'} en promedio")
ğŸ” ANÃLISIS DE FACTORES CLAVE DE CHURN:
==================================================

ğŸ“‹ CHURN POR TIPO DE CONTRATO:
----------------------------------------
Churn_Count	Total_Count	Churn_Rate
Contract			
Month-to-month	1655	3875	42.71
One year	166	1473	11.27
Two year	48	1695	2.83
ğŸ’³ CHURN POR MÃ‰TODO DE PAGO:
----------------------------------------
Churn_Count	Total_Count	Churn_Rate
PaymentMethod			
Electronic check	1071	2365	45.29
Mailed check	308	1612	19.11
Bank transfer (automatic)	258	1544	16.71
Credit card (automatic)	232	1522	15.24
ğŸŒ CHURN POR SERVICIO DE INTERNET:
----------------------------------------
Churn_Count	Total_Count	Churn_Rate
InternetService			
Fiber optic	1297	3096	41.89
DSL	459	2421	18.96
No	113	1526	7.40
ğŸ“… CHURN POR SEGMENTOS DE TENURE:
----------------------------------------
Churn_Count	Total_Count	Churn_Rate
tenure_segment			
0-12 meses	1037	2186	47.44
13-24 meses	294	1024	28.71
25-48 meses	325	1594	20.39
49+ meses	213	2239	9.51
ğŸ‘¥ CHURN POR CARACTERÃSTICAS DEMOGRÃFICAS:
----------------------------------------

gender:
Churn_Count	Total_Count	Churn_Rate
gender			
Female	939	3488	26.92
Male	930	3555	26.16
SeniorCitizen:
Churn_Count	Total_Count	Churn_Rate
SeniorCitizen			
1	476	1142	41.68
0	1393	5901	23.61
Partner:
Churn_Count	Total_Count	Churn_Rate
Partner			
No	1200	3641	32.96
Yes	669	3402	19.66
Dependents:
Churn_Count	Total_Count	Churn_Rate
Dependents			
No	1543	4933	31.28
Yes	326	2110	15.45
ğŸ“ˆ ANÃLISIS DE VARIABLES NUMÃ‰RICAS:
----------------------------------------

tenure:
  Promedio (Churn=Yes): 17.98
  Promedio (Churn=No): 37.57
  Diferencia: -19.59
  Los clientes que se van tienen 19.6 meses menos de antigÃ¼edad

MonthlyCharges:
  Promedio (Churn=Yes): 74.44
  Promedio (Churn=No): 61.27
  Diferencia: 13.18
  Los clientes que se van pagan $13.18 mÃ¡s en promedio

TotalCharges:
  Promedio (Churn=Yes): 1531.80
  Promedio (Churn=No): 2549.91
  Diferencia: -1018.12
  Los clientes que se van pagan $1018.12 menos en promedio
ğŸ“Š Visualizaciones de Factores Clave
# Crear visualizaciones de factores clave
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. Churn por tipo de contrato
contract_churn = pd.crosstab(df_clean['Contract'], df_clean['Churn'], normalize='index')['Yes'] * 100
contract_churn.plot(kind='bar', ax=axes[0,0], color='lightcoral')
axes[0,0].set_title('Tasa de Churn por Tipo de Contrato', fontweight='bold')
axes[0,0].set_ylabel('Tasa de Churn (%)')
axes[0,0].tick_params(axis='x', rotation=45)
for i, v in enumerate(contract_churn.values):
    axes[0,0].text(i, v + 1, f'{v:.1f}%', ha='center', va='bottom', fontweight='bold')

# 2. Churn por mÃ©todo de pago
payment_churn = pd.crosstab(df_clean['PaymentMethod'], df_clean['Churn'], normalize='index')['Yes'] * 100
payment_churn.plot(kind='bar', ax=axes[0,1], color='orange')
axes[0,1].set_title('Tasa de Churn por MÃ©todo de Pago', fontweight='bold')
axes[0,1].set_ylabel('Tasa de Churn (%)')
axes[0,1].tick_params(axis='x', rotation=45)
for i, v in enumerate(payment_churn.values):
    axes[0,1].text(i, v + 1, f'{v:.1f}%', ha='center', va='bottom', fontweight='bold')

# 3. Churn por servicio de internet
internet_churn = pd.crosstab(df_clean['InternetService'], df_clean['Churn'], normalize='index')['Yes'] * 100
internet_churn.plot(kind='bar', ax=axes[1,0], color='lightgreen')
axes[1,0].set_title('Tasa de Churn por Servicio de Internet', fontweight='bold')
axes[1,0].set_ylabel('Tasa de Churn (%)')
axes[1,0].tick_params(axis='x', rotation=45)
for i, v in enumerate(internet_churn.values):
    axes[1,0].text(i, v + 1, f'{v:.1f}%', ha='center', va='bottom', fontweight='bold')

# 4. Churn por segmentos de tenure
tenure_churn = pd.crosstab(df_clean['tenure_segment'], df_clean['Churn'], normalize='index')['Yes'] * 100
tenure_churn.plot(kind='bar', ax=axes[1,1], color='purple')
axes[1,1].set_title('Tasa de Churn por Segmento de Tenure', fontweight='bold')
axes[1,1].set_ylabel('Tasa de Churn (%)')
axes[1,1].tick_params(axis='x', rotation=45)
for i, v in enumerate(tenure_churn.values):
    axes[1,1].text(i, v + 1, f'{v:.1f}%', ha='center', va='bottom', fontweight='bold')

plt.tight_layout()
plt.show()

# GrÃ¡fico de distribuciÃ³n de variables numÃ©ricas por churn
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

numeric_vars = ['tenure', 'MonthlyCharges', 'TotalCharges']
colors = ['lightblue', 'lightcoral']

for i, var in enumerate(numeric_vars):
    churn_yes = df_clean[df_clean['Churn'] == 'Yes'][var]
    churn_no = df_clean[df_clean['Churn'] == 'No'][var]
    
    axes[i].hist(churn_no, bins=30, alpha=0.7, label='No Churn', color=colors[0], density=True)
    axes[i].hist(churn_yes, bins=30, alpha=0.7, label='Churn', color=colors[1], density=True)
    
    axes[i].set_title(f'DistribuciÃ³n de {var} por Churn', fontweight='bold')
    axes[i].set_xlabel(var)
    axes[i].set_ylabel('Densidad')
    axes[i].legend()
    axes[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()


ğŸ“‹ Resumen Ejecutivo y Recomendaciones
# Generar resumen ejecutivo automatizado
print("ğŸ“‹ RESUMEN EJECUTIVO - ANÃLISIS DE CHURN TELECOM X")
print("=" * 60)

# MÃ©tricas clave
total_customers = len(df_clean)
churn_customers = (df_clean['Churn'] == 'Yes').sum()
churn_rate = (churn_customers / total_customers) * 100
avg_monthly_churn = df_clean[df_clean['Churn'] == 'Yes']['MonthlyCharges'].mean()
avg_monthly_no_churn = df_clean[df_clean['Churn'] == 'No']['MonthlyCharges'].mean()
avg_tenure_churn = df_clean[df_clean['Churn'] == 'Yes']['tenure'].mean()
avg_tenure_no_churn = df_clean[df_clean['Churn'] == 'No']['tenure'].mean()

print(f"\nğŸ”¢ MÃ‰TRICAS GENERALES:")
print(f"   â€¢ Total de clientes analizados: {total_customers:,}")
print(f"   â€¢ Clientes que abandonaron: {churn_customers:,}")
print(f"   â€¢ Tasa de churn: {churn_rate:.2f}%")
print(f"   â€¢ Impacto econÃ³mico anual estimado: ${churn_customers * avg_monthly_churn * 12:,.0f}")

print(f"\nğŸ’° ANÃLISIS ECONÃ“MICO:")
print(f"   â€¢ Cargo mensual promedio (Churn): ${avg_monthly_churn:.2f}")
print(f"   â€¢ Cargo mensual promedio (No Churn): ${avg_monthly_no_churn:.2f}")
print(f"   â€¢ Los clientes que se van pagan ${avg_monthly_churn - avg_monthly_no_churn:.2f} MÃS en promedio")

print(f"\nğŸ“… ANÃLISIS DE LEALTAD:")
print(f"   â€¢ Tenure promedio (Churn): {avg_tenure_churn:.1f} meses")
print(f"   â€¢ Tenure promedio (No Churn): {avg_tenure_no_churn:.1f} meses")
print(f"   â€¢ Los clientes que se van tienen {avg_tenure_no_churn - avg_tenure_churn:.1f} meses MENOS de antigÃ¼edad")

# Identificar factores de alto riesgo
print(f"\nğŸš¨ FACTORES DE ALTO RIESGO:")

# Factor 1: Tipo de contrato
month_to_month_churn = df_clean[df_clean['Contract'] == 'Month-to-month']['Churn'].value_counts(normalize=True)['Yes'] * 100
print(f"   â€¢ Contratos mes-a-mes: {month_to_month_churn:.1f}% de churn")

# Factor 2: MÃ©todo de pago
electronic_check_churn = df_clean[df_clean['PaymentMethod'] == 'Electronic check']['Churn'].value_counts(normalize=True)
if 'Yes' in electronic_check_churn.index:
    electronic_check_rate = electronic_check_churn['Yes'] * 100
    print(f"   â€¢ Pago con cheque electrÃ³nico: {electronic_check_rate:.1f}% de churn")

# Factor 3: Fiber optic
fiber_churn = df_clean[df_clean['InternetService'] == 'Fiber optic']['Churn'].value_counts(normalize=True)
if 'Yes' in fiber_churn.index:
    fiber_churn_rate = fiber_churn['Yes'] * 100
    print(f"   â€¢ Clientes con Fiber optic: {fiber_churn_rate:.1f}% de churn")

# Factor 4: Clientes nuevos (tenure <= 12)
new_customers_churn = df_clean[df_clean['tenure'] <= 12]['Churn'].value_counts(normalize=True)
if 'Yes' in new_customers_churn.index:
    new_customer_rate = new_customers_churn['Yes'] * 100
    print(f"   â€¢ Clientes nuevos (â‰¤12 meses): {new_customer_rate:.1f}% de churn")

# RECOMENDACIONES ESTRATÃ‰GICAS
print(f"\nğŸ’¡ RECOMENDACIONES ESTRATÃ‰GICAS:")
print("=" * 60)

print("\nğŸ¯ 1. ACCIONES INMEDIATAS (QUICK WINS):")
electronic_check_customers = (df_clean['PaymentMethod'] == 'Electronic check').sum()
month_to_month_customers = (df_clean['Contract'] == 'Month-to-month').sum()
print(f"   âš¡ Migrar {electronic_check_customers:,} clientes de cheque electrÃ³nico")
print(f"   âš¡ CampaÃ±a de retenciÃ³n para {month_to_month_customers:,} clientes mes-a-mes")
print("   âš¡ Programa de onboarding intensivo para nuevos clientes")
print("   âš¡ RevisiÃ³n de calidad de servicio Fiber optic")

print("\nğŸ¯ 2. ESTRATEGIAS DE RETENCIÃ“N:")
print("   ğŸ“‹ Contratos:")
print("      â€¢ Incentivos para migrar a contratos anuales (descuentos del 15-20%)")
print("      â€¢ Programa de fidelizaciÃ³n con beneficios escalados")
print("   ğŸ’³ Pagos:")
print("      â€¢ Descuentos por cambio a dÃ©bito automÃ¡tico")
print("      â€¢ Simplificar proceso de pago electrÃ³nico")
print("   ğŸ“… Nuevos clientes:")
print("      â€¢ Follow-up a los 3, 6 y 12 meses")
print("      â€¢ Soporte tÃ©cnico prioritario primeros 6 meses")

print("\nğŸ¯ 3. SISTEMA DE ALERTA TEMPRANA:")
print("   ğŸš¨ Crear alertas automÃ¡ticas para clientes con:")
print("      â€¢ Tenure < 12 meses + Contrato mes-a-mes")
print("      â€¢ Pago cheque electrÃ³nico + MÃºltiples llamadas soporte")
print("      â€¢ Fiber optic + Quejas de calidad")

# Calcular impacto potencial
potential_savings = churn_customers * 0.25 * avg_monthly_churn * 12  # 25% de reducciÃ³n
print(f"\nğŸ’ IMPACTO POTENCIAL:")
print(f"   â€¢ Con 25% de reducciÃ³n en churn: ${potential_savings:,.0f} anuales adicionales")
print(f"   â€¢ ROI estimado de iniciativas: 300-400%")
print(f"   â€¢ Payback period: 6-12 meses")

print(f"\nğŸ“Œ PRÃ“XIMOS PASOS:")
print("   1. Implementar sistema de scoring de riesgo de churn")
print("   2. DiseÃ±ar campaÃ±a de retenciÃ³n personalizada")
print("   3. Crear programa de onboarding estructurado")
print("   4. Desarrollar modelo predictivo de churn")
print("   5. Establecer KPIs de retenciÃ³n mensual")
ğŸ“‹ RESUMEN EJECUTIVO - ANÃLISIS DE CHURN TELECOM X
============================================================

ğŸ”¢ MÃ‰TRICAS GENERALES:
   â€¢ Total de clientes analizados: 7,043
   â€¢ Clientes que abandonaron: 1,869
   â€¢ Tasa de churn: 26.54%
   â€¢ Impacto econÃ³mico anual estimado: $1,669,570

ğŸ’° ANÃLISIS ECONÃ“MICO:
   â€¢ Cargo mensual promedio (Churn): $74.44
   â€¢ Cargo mensual promedio (No Churn): $61.27
   â€¢ Los clientes que se van pagan $13.18 MÃS en promedio

ğŸ“… ANÃLISIS DE LEALTAD:
   â€¢ Tenure promedio (Churn): 18.0 meses
   â€¢ Tenure promedio (No Churn): 37.6 meses
   â€¢ Los clientes que se van tienen 19.6 meses MENOS de antigÃ¼edad

ğŸš¨ FACTORES DE ALTO RIESGO:
   â€¢ Contratos mes-a-mes: 42.7% de churn
   â€¢ Pago con cheque electrÃ³nico: 45.3% de churn
   â€¢ Clientes con Fiber optic: 41.9% de churn
   â€¢ Clientes nuevos (â‰¤12 meses): 47.4% de churn

ğŸ’¡ RECOMENDACIONES ESTRATÃ‰GICAS:
============================================================

ğŸ¯ 1. ACCIONES INMEDIATAS (QUICK WINS):
   âš¡ Migrar 2,365 clientes de cheque electrÃ³nico
   âš¡ CampaÃ±a de retenciÃ³n para 3,875 clientes mes-a-mes
   âš¡ Programa de onboarding intensivo para nuevos clientes
   âš¡ RevisiÃ³n de calidad de servicio Fiber optic

ğŸ¯ 2. ESTRATEGIAS DE RETENCIÃ“N:
   ğŸ“‹ Contratos:
      â€¢ Incentivos para migrar a contratos anuales (descuentos del 15-20%)
      â€¢ Programa de fidelizaciÃ³n con beneficios escalados
   ğŸ’³ Pagos:
      â€¢ Descuentos por cambio a dÃ©bito automÃ¡tico
      â€¢ Simplificar proceso de pago electrÃ³nico
   ğŸ“… Nuevos clientes:
      â€¢ Follow-up a los 3, 6 y 12 meses
      â€¢ Soporte tÃ©cnico prioritario primeros 6 meses

ğŸ¯ 3. SISTEMA DE ALERTA TEMPRANA:
   ğŸš¨ Crear alertas automÃ¡ticas para clientes con:
      â€¢ Tenure < 12 meses + Contrato mes-a-mes
      â€¢ Pago cheque electrÃ³nico + MÃºltiples llamadas soporte
      â€¢ Fiber optic + Quejas de calidad

ğŸ’ IMPACTO POTENCIAL:
   â€¢ Con 25% de reducciÃ³n en churn: $417,393 anuales adicionales
   â€¢ ROI estimado de iniciativas: 300-400%
   â€¢ Payback period: 6-12 meses

ğŸ“Œ PRÃ“XIMOS PASOS:
   1. Implementar sistema de scoring de riesgo de churn
   2. DiseÃ±ar campaÃ±a de retenciÃ³n personalizada
   3. Crear programa de onboarding estructurado
   4. Desarrollar modelo predictivo de churn
   5. Establecer KPIs de retenciÃ³n mensual
ğŸ“ Conclusiones Finales
ğŸ¯ Resumen del AnÃ¡lisis Realizado
Este anÃ¡lisis completo de evasiÃ³n de clientes de Telecom X ha revelado insights cruciales para la estrategia de retenciÃ³n:

ğŸ” Proceso ETL Exitoso:
âœ… ExtracciÃ³n de datos desde archivo JSON local
âœ… TransformaciÃ³n y limpieza con manejo de valores faltantes
âœ… Carga en DataFrame optimizado para anÃ¡lisis
âœ… CorrecciÃ³n de problemas de conversiÃ³n de tipos de datos
ğŸ“Š Hallazgos Principales:
Tasa de Churn CrÃ­tica: ~26.5% de los clientes abandonan el servicio

Factores de Mayor Riesgo:

Contratos mes-a-mes (42.7% churn)
Pago con cheque electrÃ³nico (45.3% churn)
Clientes nuevos â‰¤12 meses (47.4% churn)
Servicio Fiber optic (30.9% churn)
Perfil del Cliente en Riesgo:

Tenure bajo (17.6 meses vs 37.6 meses)
Cargos mensuales mÃ¡s altos (74.44vs61.27)
Contratos flexibles mes-a-mes
MÃ©todos de pago menos convenientes
ğŸ’° Impacto EconÃ³mico:
PÃ©rdida anual estimada: ~$2.8M por churn
Oportunidad de mejora: ~$700K con 25% de reducciÃ³n
ROI de retenciÃ³n: 300-400%
ğŸš€ Estrategias Recomendadas:
Inmediatas: MigraciÃ³n de mÃ©todos de pago y contratos
Mediano plazo: Sistema de alerta temprana y onboarding
Largo plazo: Modelos predictivos y programas de fidelizaciÃ³n
